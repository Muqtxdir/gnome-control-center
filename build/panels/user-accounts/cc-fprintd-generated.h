/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */

#ifndef __CC_FPRINTD_GENERATED_H__
#define __CC_FPRINTD_GENERATED_H__

#include <gio/gio.h>

G_BEGIN_DECLS


/* ------------------------------------------------------------------------ */
/* Declarations for net.reactivated.Fprint.Device */

#define CC_FPRINTD_TYPE_DEVICE (cc_fprintd_device_get_type ())
#define CC_FPRINTD_DEVICE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_FPRINTD_TYPE_DEVICE, CcFprintdDevice))
#define CC_FPRINTD_IS_DEVICE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_FPRINTD_TYPE_DEVICE))
#define CC_FPRINTD_DEVICE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), CC_FPRINTD_TYPE_DEVICE, CcFprintdDeviceIface))

struct _CcFprintdDevice;
typedef struct _CcFprintdDevice CcFprintdDevice;
typedef struct _CcFprintdDeviceIface CcFprintdDeviceIface;

struct _CcFprintdDeviceIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_claim) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_username);

  gboolean (*handle_delete_enrolled_fingers) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_username);

  gboolean (*handle_delete_enrolled_fingers2) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_enroll_start) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_finger_name);

  gboolean (*handle_enroll_stop) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_list_enrolled_fingers) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_username);

  gboolean (*handle_release) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_verify_start) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_finger_name);

  gboolean (*handle_verify_stop) (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

  const gchar * (*get_name) (CcFprintdDevice *object);

  gint  (*get_num_enroll_stages) (CcFprintdDevice *object);

  const gchar * (*get_scan_type) (CcFprintdDevice *object);

  void (*enroll_status) (
    CcFprintdDevice *object,
    const gchar *arg_result,
    gboolean arg_done);

  void (*verify_finger_selected) (
    CcFprintdDevice *object,
    const gchar *arg_finger_name);

  void (*verify_status) (
    CcFprintdDevice *object,
    const gchar *arg_result,
    gboolean arg_done);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CcFprintdDevice, g_object_unref)
#endif

GType cc_fprintd_device_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *cc_fprintd_device_interface_info (void);
guint cc_fprintd_device_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void cc_fprintd_device_complete_list_enrolled_fingers (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *enrolled_fingers);

void cc_fprintd_device_complete_delete_enrolled_fingers (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_delete_enrolled_fingers2 (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_claim (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_release (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_verify_start (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_verify_stop (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_enroll_start (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);

void cc_fprintd_device_complete_enroll_stop (
    CcFprintdDevice *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void cc_fprintd_device_emit_verify_finger_selected (
    CcFprintdDevice *object,
    const gchar *arg_finger_name);

void cc_fprintd_device_emit_verify_status (
    CcFprintdDevice *object,
    const gchar *arg_result,
    gboolean arg_done);

void cc_fprintd_device_emit_enroll_status (
    CcFprintdDevice *object,
    const gchar *arg_result,
    gboolean arg_done);



/* D-Bus method calls: */
void cc_fprintd_device_call_list_enrolled_fingers (
    CcFprintdDevice *proxy,
    const gchar *arg_username,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_list_enrolled_fingers_finish (
    CcFprintdDevice *proxy,
    gchar ***out_enrolled_fingers,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_list_enrolled_fingers_sync (
    CcFprintdDevice *proxy,
    const gchar *arg_username,
    gchar ***out_enrolled_fingers,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_delete_enrolled_fingers (
    CcFprintdDevice *proxy,
    const gchar *arg_username,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_delete_enrolled_fingers_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_delete_enrolled_fingers_sync (
    CcFprintdDevice *proxy,
    const gchar *arg_username,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_delete_enrolled_fingers2 (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_delete_enrolled_fingers2_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_delete_enrolled_fingers2_sync (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_claim (
    CcFprintdDevice *proxy,
    const gchar *arg_username,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_claim_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_claim_sync (
    CcFprintdDevice *proxy,
    const gchar *arg_username,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_release (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_release_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_release_sync (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_verify_start (
    CcFprintdDevice *proxy,
    const gchar *arg_finger_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_verify_start_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_verify_start_sync (
    CcFprintdDevice *proxy,
    const gchar *arg_finger_name,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_verify_stop (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_verify_stop_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_verify_stop_sync (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_enroll_start (
    CcFprintdDevice *proxy,
    const gchar *arg_finger_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_enroll_start_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_enroll_start_sync (
    CcFprintdDevice *proxy,
    const gchar *arg_finger_name,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_device_call_enroll_stop (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_device_call_enroll_stop_finish (
    CcFprintdDevice *proxy,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_device_call_enroll_stop_sync (
    CcFprintdDevice *proxy,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *cc_fprintd_device_get_name (CcFprintdDevice *object);
gchar *cc_fprintd_device_dup_name (CcFprintdDevice *object);
void cc_fprintd_device_set_name (CcFprintdDevice *object, const gchar *value);

gint cc_fprintd_device_get_num_enroll_stages (CcFprintdDevice *object);
void cc_fprintd_device_set_num_enroll_stages (CcFprintdDevice *object, gint value);

const gchar *cc_fprintd_device_get_scan_type (CcFprintdDevice *object);
gchar *cc_fprintd_device_dup_scan_type (CcFprintdDevice *object);
void cc_fprintd_device_set_scan_type (CcFprintdDevice *object, const gchar *value);


/* ---- */

#define CC_FPRINTD_TYPE_DEVICE_PROXY (cc_fprintd_device_proxy_get_type ())
#define CC_FPRINTD_DEVICE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_FPRINTD_TYPE_DEVICE_PROXY, CcFprintdDeviceProxy))
#define CC_FPRINTD_DEVICE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), CC_FPRINTD_TYPE_DEVICE_PROXY, CcFprintdDeviceProxyClass))
#define CC_FPRINTD_DEVICE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_FPRINTD_TYPE_DEVICE_PROXY, CcFprintdDeviceProxyClass))
#define CC_FPRINTD_IS_DEVICE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_FPRINTD_TYPE_DEVICE_PROXY))
#define CC_FPRINTD_IS_DEVICE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), CC_FPRINTD_TYPE_DEVICE_PROXY))

typedef struct _CcFprintdDeviceProxy CcFprintdDeviceProxy;
typedef struct _CcFprintdDeviceProxyClass CcFprintdDeviceProxyClass;
typedef struct _CcFprintdDeviceProxyPrivate CcFprintdDeviceProxyPrivate;

struct _CcFprintdDeviceProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  CcFprintdDeviceProxyPrivate *priv;
};

struct _CcFprintdDeviceProxyClass
{
  GDBusProxyClass parent_class;
};

GType cc_fprintd_device_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CcFprintdDeviceProxy, g_object_unref)
#endif

void cc_fprintd_device_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
CcFprintdDevice *cc_fprintd_device_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
CcFprintdDevice *cc_fprintd_device_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void cc_fprintd_device_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
CcFprintdDevice *cc_fprintd_device_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
CcFprintdDevice *cc_fprintd_device_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define CC_FPRINTD_TYPE_DEVICE_SKELETON (cc_fprintd_device_skeleton_get_type ())
#define CC_FPRINTD_DEVICE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_FPRINTD_TYPE_DEVICE_SKELETON, CcFprintdDeviceSkeleton))
#define CC_FPRINTD_DEVICE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), CC_FPRINTD_TYPE_DEVICE_SKELETON, CcFprintdDeviceSkeletonClass))
#define CC_FPRINTD_DEVICE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_FPRINTD_TYPE_DEVICE_SKELETON, CcFprintdDeviceSkeletonClass))
#define CC_FPRINTD_IS_DEVICE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_FPRINTD_TYPE_DEVICE_SKELETON))
#define CC_FPRINTD_IS_DEVICE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), CC_FPRINTD_TYPE_DEVICE_SKELETON))

typedef struct _CcFprintdDeviceSkeleton CcFprintdDeviceSkeleton;
typedef struct _CcFprintdDeviceSkeletonClass CcFprintdDeviceSkeletonClass;
typedef struct _CcFprintdDeviceSkeletonPrivate CcFprintdDeviceSkeletonPrivate;

struct _CcFprintdDeviceSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  CcFprintdDeviceSkeletonPrivate *priv;
};

struct _CcFprintdDeviceSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType cc_fprintd_device_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CcFprintdDeviceSkeleton, g_object_unref)
#endif

CcFprintdDevice *cc_fprintd_device_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for net.reactivated.Fprint.Manager */

#define CC_FPRINTD_TYPE_MANAGER (cc_fprintd_manager_get_type ())
#define CC_FPRINTD_MANAGER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_FPRINTD_TYPE_MANAGER, CcFprintdManager))
#define CC_FPRINTD_IS_MANAGER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_FPRINTD_TYPE_MANAGER))
#define CC_FPRINTD_MANAGER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), CC_FPRINTD_TYPE_MANAGER, CcFprintdManagerIface))

struct _CcFprintdManager;
typedef struct _CcFprintdManager CcFprintdManager;
typedef struct _CcFprintdManagerIface CcFprintdManagerIface;

struct _CcFprintdManagerIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_get_default_device) (
    CcFprintdManager *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_get_devices) (
    CcFprintdManager *object,
    GDBusMethodInvocation *invocation);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CcFprintdManager, g_object_unref)
#endif

GType cc_fprintd_manager_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *cc_fprintd_manager_interface_info (void);
guint cc_fprintd_manager_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void cc_fprintd_manager_complete_get_devices (
    CcFprintdManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *devices);

void cc_fprintd_manager_complete_get_default_device (
    CcFprintdManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *device);



/* D-Bus method calls: */
void cc_fprintd_manager_call_get_devices (
    CcFprintdManager *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_manager_call_get_devices_finish (
    CcFprintdManager *proxy,
    gchar ***out_devices,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_manager_call_get_devices_sync (
    CcFprintdManager *proxy,
    gchar ***out_devices,
    GCancellable *cancellable,
    GError **error);

void cc_fprintd_manager_call_get_default_device (
    CcFprintdManager *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean cc_fprintd_manager_call_get_default_device_finish (
    CcFprintdManager *proxy,
    gchar **out_device,
    GAsyncResult *res,
    GError **error);

gboolean cc_fprintd_manager_call_get_default_device_sync (
    CcFprintdManager *proxy,
    gchar **out_device,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define CC_FPRINTD_TYPE_MANAGER_PROXY (cc_fprintd_manager_proxy_get_type ())
#define CC_FPRINTD_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_FPRINTD_TYPE_MANAGER_PROXY, CcFprintdManagerProxy))
#define CC_FPRINTD_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), CC_FPRINTD_TYPE_MANAGER_PROXY, CcFprintdManagerProxyClass))
#define CC_FPRINTD_MANAGER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_FPRINTD_TYPE_MANAGER_PROXY, CcFprintdManagerProxyClass))
#define CC_FPRINTD_IS_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_FPRINTD_TYPE_MANAGER_PROXY))
#define CC_FPRINTD_IS_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), CC_FPRINTD_TYPE_MANAGER_PROXY))

typedef struct _CcFprintdManagerProxy CcFprintdManagerProxy;
typedef struct _CcFprintdManagerProxyClass CcFprintdManagerProxyClass;
typedef struct _CcFprintdManagerProxyPrivate CcFprintdManagerProxyPrivate;

struct _CcFprintdManagerProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  CcFprintdManagerProxyPrivate *priv;
};

struct _CcFprintdManagerProxyClass
{
  GDBusProxyClass parent_class;
};

GType cc_fprintd_manager_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CcFprintdManagerProxy, g_object_unref)
#endif

void cc_fprintd_manager_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
CcFprintdManager *cc_fprintd_manager_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
CcFprintdManager *cc_fprintd_manager_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void cc_fprintd_manager_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
CcFprintdManager *cc_fprintd_manager_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
CcFprintdManager *cc_fprintd_manager_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define CC_FPRINTD_TYPE_MANAGER_SKELETON (cc_fprintd_manager_skeleton_get_type ())
#define CC_FPRINTD_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), CC_FPRINTD_TYPE_MANAGER_SKELETON, CcFprintdManagerSkeleton))
#define CC_FPRINTD_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), CC_FPRINTD_TYPE_MANAGER_SKELETON, CcFprintdManagerSkeletonClass))
#define CC_FPRINTD_MANAGER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), CC_FPRINTD_TYPE_MANAGER_SKELETON, CcFprintdManagerSkeletonClass))
#define CC_FPRINTD_IS_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), CC_FPRINTD_TYPE_MANAGER_SKELETON))
#define CC_FPRINTD_IS_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), CC_FPRINTD_TYPE_MANAGER_SKELETON))

typedef struct _CcFprintdManagerSkeleton CcFprintdManagerSkeleton;
typedef struct _CcFprintdManagerSkeletonClass CcFprintdManagerSkeletonClass;
typedef struct _CcFprintdManagerSkeletonPrivate CcFprintdManagerSkeletonPrivate;

struct _CcFprintdManagerSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  CcFprintdManagerSkeletonPrivate *priv;
};

struct _CcFprintdManagerSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType cc_fprintd_manager_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (CcFprintdManagerSkeleton, g_object_unref)
#endif

CcFprintdManager *cc_fprintd_manager_skeleton_new (void);


G_END_DECLS

#endif /* __CC_FPRINTD_GENERATED_H__ */
